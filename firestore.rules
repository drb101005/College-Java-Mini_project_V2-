/**
 * @fileoverview Firestore Security Rules for the Student Discussion Forum.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, scalable, and maintainable backend by focusing on Authorization Independence, which is achieved using data denormalization and structural segregation.  Access control is centered around user-ownership for personal data and public-read with owner-write for community content (questions).
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.  Access is restricted to the owning user.
 * - /questions/{questionId}: Stores questions.  Any authenticated user can read questions. Only the author can modify.
 * - /questions/{questionId}/answers/{answerId}: Stores answers to questions. Only the author can modify.
 * - /questions/{questionId}/answers/{answerId}/comments/{commentId}: Stores comments on answers. Only the author can modify.
 * - /tags/{tagId}: Stores tags.  Reads are public, writes are restricted.
 * - /roles_admin/{userId}: Documents in this collection indicate admin privileges for the user.
 *
 * Key Security Decisions:
 * - **No User Listing**: Listing all users is explicitly denied to protect user privacy.
 * - **Ownership Enforcement**:  Write access to user-specific data is strictly limited to the owning user.
 * - **Public Read, Owner Write for Questions**:  Questions are publicly readable, but only the author can modify them.  This is a common pattern for forum content.
 * - **Admin Roles**:  Admin privileges are granted based on the existence of a document in the `/roles_admin/{userId}` collection.
 * - **Authorization Independence via Denormalization**: Crucial for maintaining performance and security, especially in list operations, and upholding Question, Answer, and Post (QAP) principles.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Ensures that only authenticated users can access certain resources.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user-ownership for data access.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of the document.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces that only existing owners can modify or delete documents.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
    
    /**
     * @description Checks if the user has admin rights by checking existence of a document in roles_admin.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces admin-only access to certain resources.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    

    /**
     * @description Rules for user profiles.  Only the owning user can read or write their profile.
     * @path /users/{userId}
     * @allow (get, list) A user reading their own profile. (auth.uid == userId)
     * @allow (create) A user creating their own profile. (auth.uid == userId)
     * @allow (update, delete) A user updating/deleting their own profile. (auth.uid == userId)
     * @deny (get, list) A user reading another user's profile. (auth.uid != userId)
     * @deny (create, update, delete) A user creating/updating/deleting another user's profile. (auth.uid != userId)
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // No user listing allowed.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for questions. Any authenticated user can read questions. Only the author can create, update, or delete questions.
     * @path /questions/{questionId}
     * @allow (get, list) Any authenticated user reading questions.
     * @allow (create) The author creating a question with a matching authorId.
     * @allow (update, delete) The author updating/deleting their own question.
     * @deny (create) A user creating a question with a mismatched authorId.
     * @deny (update, delete) A user updating/deleting another user's question.
     * @principle Enforces public read, owner-only writes for questions.
     */
    match /questions/{questionId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for answers. Only the author can create, update, or delete answers.
     * @path /questions/{questionId}/answers/{answerId}
     * @allow (create) The author creating an answer with a matching authorId.
     * @allow (update, delete) The author updating/deleting their own answer.
     * @deny (create) A user creating an answer with a mismatched authorId.
     * @deny (update, delete) A user updating/deleting another user's answer.
     * @principle Enforces owner-only writes for answers.
     */
    match /questions/{questionId}/answers/{answerId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for comments. Only the author can create, update, or delete comments.
     * @path /questions/{questionId}/answers/{answerId}/comments/{commentId}
     * @allow (create) The author creating a comment with a matching authorId.
     * @allow (update, delete) The author updating/deleting their own comment.
     * @deny (create) A user creating a comment with a mismatched authorId.
     * @deny (update, delete) A user updating/deleting another user's comment.
     * @principle Enforces owner-only writes for comments.
     */
    match /questions/{questionId}/answers/{answerId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for tags.  Reads are public. Writes are restricted to admins only.
     * @path /tags/{tagId}
     * @allow (get, list) Any user reading tags.
     * @allow (create, update, delete) Only admins can create, update, or delete tags.
     * @deny (create, update, delete) Non-admins attempting to create, update, or delete tags.
     * @principle Restricts tag management to administrators.
     */
    match /tags/{tagId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for admin roles.  Existence of a document grants admin privileges.
     * @path /roles_admin/{userId}
     * @allow (get) Any authenticated user can check if they have admin privileges.
     * @allow (create) Only a user with admin rights can assign themselves admin privileges.
     * @allow (update, delete) Only a user with admin rights can change this document.
     * @deny (create) A non-admin user attempting to assign themself admin privileges.
     *
     * NOTE: This rule allows any authenticated user to GET the admin status of any other user. This is likely not a security concern
     * in this application, but it's something to keep in mind. If this becomes a problem, consider
     * adding a check that only admins can GET other users' admin status.
     */
     match /roles_admin/{userId} {
        allow get: if isSignedIn();
        allow create: if isAdmin();
        allow update: if isAdmin();
        allow delete: if isAdmin();
      }
  }
}