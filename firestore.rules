/**
 * @file Firebase Security Rules for Student Discussion Forum
 *
 * @core_philosophy This ruleset prioritizes user-owned data and secure relationships,
 *  using denormalization to improve performance and simplify authorization logic.
 *  It follows a strict ownership model for user profiles and a public-read, owner-write
 *  model for questions. Subcollections inherit the security context of their parent documents.
 *
 * @data_structure
 *  - /users/{userId}: Stores user profiles.
 *  - /questions/{questionId}: Stores questions.
 *  - /questions/{questionId}/answers/{answerId}: Stores answers to questions.
 *  - /questions/{questionId}/answers/{answerId}/comments/{commentId}: Stores comments on answers.
 *  - /tags/{tagId}: Stores tags.
 *  - /roles_admin/{userId}: Stores admin roles.
 *
 * @key_security_decisions
 *  - Users can only read and write their own profile data.
 *  - Questions are publicly readable, but only the author can modify them.
 *  - Subcollections (answers, comments) inherit the security context of their parent.
 *  - Listing users is disallowed to protect user privacy.
 *  - Admin privileges are granted based on the presence of a document in `/roles_admin/{userId}`.
 *
 * @denormalization_for_authorization
 *  - Questions denormalize the author's role to avoid needing to fetch the user document during listing.
 *
 * @structural_segregation
 *  - Public questions are stored in a top-level collection separate from private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles. Only the user themselves can read/write.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile: auth.uid == 'user123' and request.resource.data.id == 'user123'
     * @allow (get, update, delete) User with ID 'user123' reads their profile: auth.uid == 'user123'
     * @deny (create, update, delete) User with ID 'user456' tries to modify profile 'user123': auth.uid != 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isCreatingOwner(userId) {
        return isOwner(userId) && request.resource.data.id == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isCreatingOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to questions. Questions are publicly readable but only the author can modify them.
     * @path /questions/{questionId}
     * @allow (get, list) Any user can read any question.
     * @allow (create) User with ID 'user123' creates a question: auth.uid == 'user123' and request.resource.data.authorId == 'user123'
     * @allow (update, delete) User with ID 'user123' modifies their question: auth.uid == 'user123' and resource.data.authorId == 'user123'
     * @deny (create, update, delete) User with ID 'user456' tries to modify question 'question123' authored by 'user123'.
     * @principle Public read access with owner-only writes.
     */
    match /questions/{questionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Controls access to answers. Access is restricted to authenticated users and inherits from the parent question.
     * @path /questions/{questionId}/answers/{answerId}
     * @allow (get, list) Any authenticated user can read any answer to any question.
     * @allow (create) User with ID 'user123' creates an answer to question 'question123': auth.uid == 'user123' and request.resource.data.authorId == 'user123'
     * @allow (update, delete) User with ID 'user123' modifies their answer to question 'question123': auth.uid == 'user123' and resource.data.authorId == 'user123'
     * @deny (create, update, delete) User with ID 'user456' tries to modify answer 'answer123' authored by 'user123'.
     * @principle Inherits security context from parent question.
     */
    match /questions/{questionId}/answers/{answerId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      allow get, list: if isSignedIn();

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Controls access to comments. Access is restricted to authenticated users and inherits from the parent answer.
     * @path /questions/{questionId}/answers/{answerId}/comments/{commentId}
     * @allow (get, list) Any authenticated user can read any comment to any answer.
     * @allow (create) User with ID 'user123' creates a comment to answer 'answer123': auth.uid == 'user123' and request.resource.data.authorId == 'user123'
     * @allow (update, delete) User with ID 'user123' modifies their comment to answer 'answer123': auth.uid == 'user123' and resource.data.authorId == 'user123'
     * @deny (create, update, delete) User with ID 'user456' tries to modify comment 'comment123' authored by 'user123'.
     * @principle Inherits security context from parent answer.
     */
    match /questions/{questionId}/answers/{answerId}/comments/{commentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      allow get, list: if isSignedIn();

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Controls access to tags. All users can read tags; only admins can create, update, or delete them.
     * @path /tags/{tagId}
     * @allow (get, list) Any user can read any tag.
     * @allow (create, update, delete) Only an admin user can create, update, or delete a tag.
     * @deny (create, update, delete) Non-admin user tries to modify tag data.
     * @principle Restricts write access to admins.
     */
    match /tags/{tagId} {
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }
      allow get, list: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Grants admin privileges to users with a document in this collection.
     * @path /roles_admin/{userId}
     * @allow (create) Only the user themselves can create their admin role.
     * @allow (get) Any signed-in user can check for admin role existence (for UI purposes).
     * @deny (list) No one can list the admin roles.
     * @deny (update, delete) Admin role documents can not be updated or deleted, only created once.
     * @principle Grants admin privileges based on document existence.
     */
    match /roles_admin/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId);
      allow update, delete: if false;
    }
  }
}