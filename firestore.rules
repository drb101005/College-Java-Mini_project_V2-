/**
 * @fileoverview Firestore Security Rules for the Student Discussion Forum.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-centric model.  Users primarily have access to their own data,
 * with specific exceptions for public content and administrative roles. Data required for authorization is
 * denormalized to minimize reads and improve performance. Structural segregation (separate collections for public
 * vs. private data) is preferred over boolean flags.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the owning user.
 * - /questions/{questionId}: Publicly readable questions, with owner-only writes.  Includes `authorId` and denormalized `authorRole` for security.
 * - /questions/{questionId}/answers/{answerId}: Answers to questions, readable by everyone, but only the author can modify.
 * - /questions/{questionId}/answers/{answerId}/comments/{commentId}: Comments on answers, readable by everyone, but only the author can modify.
 * - /tags/{tagId}: Publicly readable and writable tags.
 * - /roles_admin/{userId}: Indicates admin privileges for a user.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied to prevent unauthorized access to user data.
 * - Read-only collections (if any) are explicitly marked with `allow get, list: if true;`.
 * - All write operations require authentication (`request.auth != null`).
 * - Data validation is limited to authorization-critical fields to allow for rapid prototyping.
 * - The `authorRole` is denormalized into the `Question` entity to make listing questions efficient and secure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles, ensuring only the owning user can read or write their data.
     * @path /users/{userId}
     * @allow (create, update, delete) if request.auth.uid == userId
     * @allow (get, list) if request.auth.uid == userId
     * @deny (create, update, delete) if request.auth.uid != userId
     * @deny (get, list) if request.auth.uid != userId
     * @principle Enforces strict document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource.data.id == userId;
      allow delete: if isOwner(userId) && resource.data.id == userId;
    }

    /**
     * @description Manages publicly readable questions, with owner-only writes.
     * @path /questions/{questionId}
     * @allow (get, list) if true
     * @allow (create) if request.auth != null && request.resource.data.authorId == request.auth.uid
     * @allow (update, delete) if request.auth != null && resource.data.authorId == request.auth.uid
     * @deny (create) if request.auth == null || request.resource.data.authorId != request.auth.uid
     * @deny (update, delete) if request.auth == null || resource.data.authorId != request.auth.uid
     * @principle Implements public read with owner-only write access pattern.  Validates author ownership on create, update, and delete.
     */
    match /questions/{questionId} {
      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && isExistingOwner(resource.data.authorId);
      allow delete: if request.auth != null && isExistingOwner(resource.data.authorId);

      function isExistingOwner(authorId) {
        return isOwner(authorId) && resource != null;
      }
    }

    /**
     * @description Manages answers to questions, with owner-only writes.
     * @path /questions/{questionId}/answers/{answerId}
     * @allow (get, list) if true
     * @allow (create) if request.auth != null && request.resource.data.authorId == request.auth.uid
     * @allow (update, delete) if request.auth != null && resource.data.authorId == request.auth.uid
     * @deny (create) if request.auth == null || request.resource.data.authorId != request.auth.uid
     * @deny (update, delete) if request.auth == null || resource.data.authorId != request.auth.uid
     * @principle Implements public read with owner-only write access pattern.  Validates author ownership on create, update, and delete.
     */
    match /questions/{questionId}/answers/{answerId} {
      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && isExistingOwner(resource.data.authorId);
      allow delete: if request.auth != null && isExistingOwner(resource.data.authorId);

      function isExistingOwner(authorId) {
        return isOwner(authorId) && resource != null;
      }
    }

    /**
     * @description Manages comments on answers, with owner-only writes.
     * @path /questions/{questionId}/answers/{answerId}/comments/{commentId}
     * @allow (get, list) if true
     * @allow (create) if request.auth != null && request.resource.data.authorId == request.auth.uid
     * @allow (update, delete) if request.auth != null && resource.data.authorId == request.auth.uid
     * @deny (create) if request.auth == null || request.resource.data.authorId != request.auth.uid
     * @deny (update, delete) if request.auth == null || resource.data.authorId != request.auth.uid
     * @principle Implements public read with owner-only write access pattern.  Validates author ownership on create, update, and delete.
     */
    match /questions/{questionId}/answers/{answerId}/comments/{commentId} {
      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && isExistingOwner(resource.data.authorId);
      allow delete: if request.auth != null && isExistingOwner(resource.data.authorId);

      function isExistingOwner(authorId) {
        return isOwner(authorId) && resource != null;
      }
    }

    /**
     * @description Manages publicly readable and writable tags.
     * @path /tags/{tagId}
     * @allow get, list, create, update, delete: if true;
     * @principle Allows public access to tags.
     */
    match /tags/{tagId} {
      allow get, list, create, update, delete: if true;
    }

    /**
     * @description Grants admin privileges to users who have a document in this collection.
     * @path /roles_admin/{userId}
     * @allow create, update, delete, get: if request.auth.uid == userId;
     * @allow list: if false; // Explicitly disallow listing admin roles.
     * @principle Grants administrative privileges based on document existence.
     */
    match /roles_admin/{userId} {
      function isAdmin(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isAdmin(userId);
      allow list: if false;
      allow create: if isAdmin(userId);
      allow update: if isAdmin(userId);
      allow delete: if isAdmin(userId);
    }
    
   /**
     * @description Denies listing users collection
     * @path /users
     * @deny list
     * @principle The list operation was denied due to missing permissions
     */
    match /users {
        allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}