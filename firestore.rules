/**
 * @file Firestore Security Rules for Student Discussion Forum
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for user profiles and a public-read, owner-write model for questions, answers, and comments.
 * Admin privileges are granted based on the existence of a document in the `roles_admin` collection.
 *
 * @data_structure
 * - `/users/{userId}`: Stores user profiles.
 * - `/questions/{questionId}`: Stores questions.
 * - `/questions/{questionId}/answers/{answerId}`: Stores answers to questions.
 * - `/questions/{questionId}/answers/{answerId}/comments/{commentId}`: Stores comments on answers.
 * - `/tags/{tagId}`: Stores tags.
 * - `/roles_admin/{userId}`:  Indicates admin status for a user.
 *
 * @key_security_decisions
 * - Users can only read/write their own profile data.
 * - Questions are publicly readable, but only the author can modify them.
 * - Answers and comments follow the same public-read, owner-write model.
 * - Listing of users is disallowed for privacy.
 * - Admin privileges are explicitly managed through the `roles_admin` collection.
 *
 * @denormalization_for_authorization
 * - Questions include the author's ID (`authorId`) to simplify ownership checks.
 *
 * @structural_segregation
 * - Public questions are stored in a top-level collection (`/questions`) to enable public listing without exposing private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) Signed-in user can create their own profile.
     * @allow (get, list, update, delete) Signed-in user can read, update, and delete their own profile.
     * @deny (create)  User cannot create a profile with an ID that doesn't match their auth UID.
     * @deny (get, list, update, delete) Another user attempts to access or modify this user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Disallowing listing of users for privacy.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to questions.
     * @path /questions/{questionId}
     * @allow (get, list) Any user can read any question.
     * @allow (create) Signed-in user can create a question with their UID as the authorId.
     * @allow (update, delete) Only the author of the question can update or delete it.
     * @deny (create) A user attempts to create a question with an authorId that doesn't match their UID.
     * @deny (update, delete) Another user attempts to update or delete this question.
     * @principle Enforces public read access with owner-only writes for questions.
     */
    match /questions/{questionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.authorId;
      }
      
      function isCreatingOwner() {
        return request.auth.uid == request.resource.data.authorId;
      }
      
      function isExistingOwner() {
        return isOwner() && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isCreatingOwner();
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to answers for a specific question.
     * @path /questions/{questionId}/answers/{answerId}
     * @allow (get, list) Any user can read any answer.
     * @allow (create) Signed-in user can create an answer with their UID as the authorId.
     * @allow (update, delete) Only the author of the answer can update or delete it.
     * @deny (create) A user attempts to create an answer with an authorId that doesn't match their UID.
     * @deny (update, delete) Another user attempts to update or delete this answer.
     * @principle Enforces public read access with owner-only writes for answers.
     */
    match /questions/{questionId}/answers/{answerId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.authorId;
      }

      function isCreatingOwner() {
        return request.auth.uid == request.resource.data.authorId;
      }

      function isExistingOwner() {
        return isOwner() && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isCreatingOwner();
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to comments for a specific answer.
     * @path /questions/{questionId}/answers/{answerId}/comments/{commentId}
     * @allow (get, list) Any user can read any comment.
     * @allow (create) Signed-in user can create a comment with their UID as the authorId.
     * @allow (update, delete) Only the author of the comment can update or delete it.
     * @deny (create) A user attempts to create a comment with an authorId that doesn't match their UID.
     * @deny (update, delete) Another user attempts to update or delete this comment.
     * @principle Enforces public read access with owner-only writes for comments.
     */
    match /questions/{questionId}/answers/{answerId}/comments/{commentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.authorId;
      }

      function isCreatingOwner() {
        return request.auth.uid == request.resource.data.authorId;
      }
      
      function isExistingOwner() {
        return isOwner() && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isCreatingOwner();
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to tags.
     * @path /tags/{tagId}
     * @allow (get, list) Any user can read any tag.
     * @allow create: if false;
     * @allow update: if false;
     * @allow delete: if false;
     * @principle Enforces public read access and no write access for tags.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Grants admin privileges to users with a document in this collection.
     * @path /roles_admin/{userId}
     */
     match /roles_admin/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isAdmin(userId);
      allow list: if false; // Disallowing listing of admins.
      allow create: if isSignedIn() && isAdmin(userId) ; // Assuming self-creation of admin role
      allow update: if false;
      allow delete: if isSignedIn() && isAdmin(userId);
    }
  }
}